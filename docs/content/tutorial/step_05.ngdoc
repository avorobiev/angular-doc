@ngdoc overview
@name Tutorial: 5 - Запросы к серверу и встраивание зависимостей
@description

<ul doc-tutorial-nav="5"></ul>


Хватит разрабатывать приложение для трех телефонов жестко заданных в начальных данных! ДАвайте запросим большую выборку данных от нашего сервера используя встроенный в angular {@link api/ng сепрвис} под названием {@link api/ng.$http $http}. Мы так же используем сервис {@link guide/di встраивания зависимостей (DI)}, чтобы передать сервис $http в контроллер `PhoneListCtrl`.


<div doc-tutorial-reset="5"></div>


Теперь на сайте должно отображаться 20 телефонов.

Основные изменения описаны ниже. Все изменения можно увидеть в диффе на {@link
https://github.com/angular/angular-phonecat/compare/step-4...step-5
GitHub}:

## Данные

Файл `app/phones/phones.json` в вашем проекте - это набор данных, содержащий список телефонов в формате JSON.

Данные в списке хранятся в следующем формате:
<pre>
[
 {
  "age": 13,
  "id": "motorola-defy-with-motoblur",
  "name": "Motorola DEFY\u2122 with MOTOBLUR\u2122",
  "snippet": "Are you ready for everything life throws your way?"
  ...
 },
...
]
</pre>


## Контроллер

Мы будем использовать встроенный в angular сервис {@link api/ng.$http $http}, чтобы из контроллера делать http-запросы к вашему серверу для получения данных из файла `app/phones/phones.json`. `$http` - это только один из встроенных в {@link api/ng angular сервисов} выполняющих часто повторяющиеся операции в вэб-приложении. Angular встраивает этот сервис туда, где он вам нужен.

Передача сервиса в нужное вам место происходит благодаря реализованной в angular {@link guide/di подсистеме встраивания зависимостей}. Встраивание зависимостей помогает сделать ваше приложение как лучше структурированным (как, например, разделение оформления, данных и контроллера) так и более слабо связанным (зависимости между компонентами разрешаются с помощью системы встраивания зависимостей, а не за счет прописывания зависимостей напрямую в коде).

__`app/js/controllers.js:`__
<pre>
function PhoneListCtrl($scope, $http) {
  $http.get('phones/phones.json').success(function(data) {
    $scope.phones = data;
  });

  $scope.orderProp = 'age';
}

//PhoneListCtrl.$inject = ['$scope', '$http'];
</pre>

`$http` отправляет HTTP GET запрос к нашему серверу, запрашивая `phone/phones.json` (url задается относительно файла `index.html`). В ответ сервер возвращает данные, которые хранятся в фале в формате JSON.
(Ответ может быть так же сгенерирован на стороне сервера динамически. Для приложения в браузере данные из статического файла или сгенерированные динамически выглядят одинаково. Для простоты, в нашем примере, мы храним данные в статическом файле.)

Сервис `$http` возвращает {@link api/ng.$q объект-обещание} в котором реализован метод `success`. Мы вызываем этот метод для получения асинхронного ответа и передачи данных о телефонах в область видимости контроллера в качестве модели с именем `phones`. Обратите внимание, что angular автоматически обнаруживает, что нами получены данные в формате JSON, и конвертирует их из строки в объект за нас!

В angular для того, чтобы встроить сервис в контроллер, вам просто надо написать его имя как название параметра в конструкторе контроллера следующим образом:

    function PhoneListCtrl($scope, $http) {...}

И тогда подсистема angular по встраиванию зависимостей передаст сервис в контроллер при его создании. Подсистема управления зависимостями так же возмет на себя заботу по инициализации передаваемого сервиса с учетом всех имеющихся зависимостей (сервисы часто сами зависят от других сервисов).

Заметьте, что очень важно использовать правильные имена сервисов в качестве названий параметров, поскольку встраивание зависимостей происходит именно по указанным названиеям.


<img  class="diagram" src="img/tutorial/xhr_service_final.png">


### '$' Соглашение о префиксах

Вы можете создавать собственные сервисы, и мы сами даже проделаем это на шаге 11. В соответствии с соглашением об именовании, встроенные в angular сервисы, области видимости (scope) и кое-что еще из APIs имеет префикс '$' в названии.  Не используйте префикс '$' при названии собственной модели или метода для предотвращения возможных коллизий.

### Замечание по оптимизации при сжатии скриптов

Since angular infers the controller's dependencies from the names of arguments to the controller's
constructor function, if you were to {@link http://en.wikipedia.org/wiki/Minification_(programming)
minify} the JavaScript code for `PhoneListCtrl` controller, all of its function arguments would be
minified as well, and the dependency injector would not be able to identify services correctly.

To overcome issues caused by minification, just assign an array with service identifier strings
into the `$inject` property of the controller function, just like the last line in the snippet
(commented out) suggests:

    PhoneListCtrl.$inject = ['$scope', '$http'];

There is also one more way to specify this dependency list and avoid minification issues — using the
bracket notation which wraps the function to be injected into an array of strings (representing the
dependency names) followed by the function to be injected:

    var PhoneListCtrl = ['$scope', '$http', function($scope, $http) { /* constructor body */ }];

Both of these methods work with any function that can be injected by Angular, so it's up to your
project's style guide to decide which one you use.


## Test

__`test/unit/controllersSpec.js`:__

Because we started using dependency injection and our controller has dependencies, constructing the
controller in our tests is a bit more complicated. We could use the `new` operator and provide the
constructor with some kind of fake `$http` implementation. However, the recommended (and easier) way
is to create a controller in the test environment in the same way that angular does it in the
production code behind the scenes, as follows:

<pre>
describe('PhoneCat controllers', function() {

  describe('PhoneListCtrl', function(){
    var scope, ctrl, $httpBackend;

    beforeEach(inject(function(_$httpBackend_, $rootScope, $controller) {
      $httpBackend = _$httpBackend_;
      $httpBackend.expectGET('phones/phones.json').
          respond([{name: 'Nexus S'}, {name: 'Motorola DROID'}]);

      scope = $rootScope.$new();
      ctrl = $controller(PhoneListCtrl, {$scope: scope});
    }));
</pre>

Note: Because we loaded Jasmine and `angular-mocks.js` in our test environment, we got two helper
methods {@link api/angular.mock.module module} and {@link api/angular.mock.inject inject} that we'll
use to access and configure the injector.

We created the controller in the test environment, as follows:

* We used the `inject` helper method to inject instances of
{@link api/ng.$rootScope $rootScope},
{@link api/ng.$controller $controller} and
{@link api/ng.$httpBackend $httpBackend} services into the Jasmine's `beforeEach`
function. These instances come from an injector which is recreated from scratch for every single
test. This guarantees that each test starts from a well known starting point and each test is
isolated from the work done in other tests.

* We created a new scope for our controller by calling `$rootScope.$new()`

* We called the injected `$controller` function passing the `PhoneListCtrl` function and the created
scope as parameters.

Because our code now uses the `$http` service to fetch the phone list data in our controller, before
we create the `PhoneListCtrl` child scope, we need to tell the testing harness to expect an
incoming request from the controller. To do this we:

* Request `$httpBackend` service to be injected into our `beforeEach` function. This is a mock
version of the service that in a production environment facilitates all XHR and JSONP requests.
The mock version of this service allows you to write tests without having to deal with
native APIs and the global state associated with them — both of which make testing a nightmare.

* Use the `$httpBackend.expectGET` method to train the `$httpBackend` service to expect an incoming
HTTP request and tell it what to respond with. Note that the responses are not returned until we call
the `$httpBackend.flush` method.

Now, we will make assertions to verify that the `phones` model doesn't exist on `scope` before
the response is received:

<pre>
    it('should create "phones" model with 2 phones fetched from xhr', function() {
      expect(scope.phones).toBeUndefined();
      $httpBackend.flush();

      expect(scope.phones).toEqual([{name: 'Nexus S'},
                                   {name: 'Motorola DROID'}]);
    });
</pre>

* We flush the request queue in the browser by calling `$httpBackend.flush()`. This causes the
promise returned by the `$http` service to be resolved with the trained response.

* We make the assertions, verifying that the phone model now exists on the scope.

Finally, we verify that the default value of `orderProp` is set correctly:

<pre>
    it('should set the default value of orderProp model', function() {
      expect(scope.orderProp).toBe('age');
    });
  });
});
</pre>

You should now see the following output in the Karma tab:

       Chrome 22.0: Executed 2 of 2 SUCCESS (0.028 secs / 0.007 secs)



# Experiments

* At the bottom of `index.html`, add a `{{phones | json}}` binding to see the list of phones
  displayed in json format.

* In the `PhoneListCtrl` controller, pre-process the http response by limiting the number of phones
to the first 5 in the list. Use the following code in the $http callback:

         $scope.phones = data.splice(0, 5);


# Summary

Now that you have learned how easy it is to use angular services (thanks to Angular's dependency
injection), go to {@link step_06 step 6}, where you will add some
thumbnail images of phones and some links.


<ul doc-tutorial-nav="5"></ul>
